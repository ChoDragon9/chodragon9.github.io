---
title: ì»´íŒŒì¼ëŸ¬ ì´ë¡  ì •ë¦¬
sidebar: auto
---

ì´ í¬ìŠ¤íŠ¸ëŠ” ì»´íŒŒì¼ëŸ¬ ê°œë…ê³¼ ë¬¸ë²•ì´ ì–´ë–»ê²Œ ë§Œë“¤ì–´ì§€ëŠ” í•™ìŠµí•˜ê³ ì ì •ë¦¬í•œ ìë£Œë‹¤.

::: warning
ìš°ì„  ì»´íŒŒì¼ëŸ¬ëŠ” ë°‘ë°”ë‹¥ë¶€í„° êµ¬í˜„í•˜ëŠ” ê²½ìš°ëŠ” ë“œë¬¼ë‹¤. ë³´í†µ í† í°í™” ëª¨ë“ˆì´ë‚˜ ë¬¸ë²• ë¶„ì„ê¸°ë¥¼ ë§Œë“¤ ë•Œ, [Flex(ì–´íœ˜ë¶„ì„ê¸°)](https://ko.wikipedia.org/wiki/Flex_(%EC%96%B4%ED%9C%98%EB%B6%84%EC%84%9D%EA%B8%B0))ì™€ [bison(íŒŒì„œ ìƒì„±ê¸°)](https://ko.wikipedia.org/wiki/GNU_bison)ê°™ì€ **ì»´íŒŒì¼ëŸ¬ ìƒì„±ê¸°** ë„êµ¬ë“¤ì„ ì´ìš©í•´ì„œ ë§Œë“ ë‹¤. ì´ ë„êµ¬ë“¤ì€ [ë¬¸ë§¥ ììœ  ë¬¸ë²•](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EC%9E%90%EC%9C%A0_%EB%AC%B8%EB%B2%95)ë¥¼ ì…ë ¥í•˜ë©´, ê·¸ ë¬¸ë²•ìœ¼ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ì„ í† í°í™”í•˜ê³  ë¶„ì„í•˜ëŠ” ë¬¸ë²• ë¶„ì„ ì½”ë“œë¥¼ ì¶œë ¥í•œë‹¤. ê·¸ë¦¬ê³  ì»´íŒŒì¼ ì¡°ê±´ì— ë§ì¶° ìƒì„± ì½”ë“œë¥¼ ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.
:::

## ì»´íŒŒì¼ëŸ¬ ê°œë…
ì»´íŒŒì¼ëŸ¬ëŠ” ì›ë³¸ ì–¸ì–´ì—ì„œ ëŒ€ìƒ ì–¸ì–´ë¡œ ë²ˆì—­í•˜ëŠ” í”„ë¡œê·¸ë¨ì´ë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ë²ˆì—­ ê³¼ì •ì„ ê°œë…ì ìœ¼ë¡œ ë¬¸ë²• ë¶„ì„ê³¼ ì½”ë“œ ìƒì„±ì´ë¼ëŠ” ë‘ ë‹¨ê³„ë¡œ ë‚˜ë‰œë‹¤.

- ë¬¸ë²• ë¶„ì„(Syntax Analysis): ì›ë³¸ ì–¸ì–´ì˜ ë¬¸ë²•ì„ ì´í•´í•˜ê³ , ì›ë³¸ ì–¸ì–´ë¥¼ [ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬](https://ko.wikipedia.org/wiki/%EC%B6%94%EC%83%81_%EA%B5%AC%EB%AC%B8_%ED%8A%B8%EB%A6%AC)ë¥¼ ë§Œë“¬
- ì½”ë“œ ìƒì„±(Code Generation): ë¬¸ë²•ì„ í†µí•´ í”„ë¡œê·¸ë¨ì˜ ì˜ë¯¸(semantics)ë¥¼ ì°¾ê³ , ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬ë¥¼ ëŒ€ìƒ ì–¸ì–´ë¡œ ë²ˆì—­í•¨

##### ğŸ“„ ì»´íŒŒì¼ëŸ¬ ì˜ì‚¬ ì½”ë“œ
```js
function compiler (originCode) {
  var ast = syntaxAnalyzer(originCode)
  var targetCode = codeGenerator(ast)
  return targetCode
}
```

### Step 1. ë¬¸ë²• ë¶„ì„ê¸°(Syntax Analyzer)
ì»´íŒŒì¼ëŸ¬ì˜ ì²«ë²ˆì§¸ ë‹¨ê³„ì¸ ë¬¸ë²• ë¶„ì„ ë‹¨ê³„ë‹¤. ë¬¸ë²• ë¶„ì„ ë‹¨ê³„ì—ì„œë„ í† í°í™”ì™€ íŒŒì‹±ì´ë¼ëŠ” ë‘ ë‹¨ê³„ë¡œ ë‚˜ë‰˜ì–´ ì§„ë‹¤.
- í† í°í™”(Tokenizing) ëª¨ë“ˆ: ì›ë³¸ ì–¸ì–´ë¥¼ ì–¸ì–´ ê¸°ë³¸ ìš”ì†Œë“¤ë¡œ ë¶„ë¥˜í•˜ëŠ” ëª¨ë“ˆ
- íŒŒì‹±(Parsing) ëª¨ë“ˆ: í† í°í™” ê²°ê³¼ë¡œ ë‚˜ì˜¨ ì–¸ì–´ ê¸°ë³¸ ìš”ì†Œ ìŠ¤íŠ¸ë¦¼ì„ ì–¸ì–´ì˜ ë¬¸ë²• ê·œì¹™ì— ë§ì¶”ëŠ” ëª¨ë“ˆ

##### ğŸ“„ ë¬¸ë²• ë¶„ì„ê¸° ì˜ì‚¬ ì½”ë“œ
```js
// ast: Abstract Syntax Tree
function syntaxAnalyzer(originCode) {
  var tokens = tokenizer(originCode)
  var ast = parser(tokens)
  return ast
}
```

#### Step 1_1. í† í°í™”(Tokenizer)
> ì´ ë‹¨ê³„ëŠ” ë³´í†µ í† í°í™”(tokenizing) ë˜ëŠ” ì–´íœ˜ ë¶„ì„(lexical analysis), ìŠ¤ìºë‹(scanning)ë¡œ ë¶ˆë¦°ë‹¤.

ë¬¸ë²• ë¶„ì„ì˜ ì²« ë‹¨ê³„ëŠ” í† í°í™” ë‹¨ê³„ë‹¤. í† í°í™”ëŠ” ê³µë°±ì´ë‚˜ ì£¼ì„ì€ ë¬´ì‹œí•˜ê³ , ë¬¸ìë“¤ì„ ì–¸ì–´ì˜ ë¬¸ë²•ì— ì •ì˜ëœ í† í°ë“¤ë¡œ ë¶„ë¥˜í•˜ëŠ” ê²ƒì´ë‹¤.
í† í°í™” ë˜ë©´, í† í°ë“¤ì€ í”„ë¡œê·¸ë¨ì˜ ê¸°ë³¸ ì›ì†Œê°€ ë˜ë©°, ì»´íŒŒì¼ëŸ¬ì˜ ì…ë ¥ë„ í† í° ìŠ¤íŠ¸ë¦¼ì´ ëœë‹¤.

##### ğŸ“„ í† í°í™” ì˜ì‚¬ ì½”ë“œ
```js
function tokenizer(originCode) {
  var tokens = [] // logic
  return tokens
}
```

í† í°ë“¤ì€ ê°ê° íŠ¹ì • ë¶„ë¥˜ ë˜ëŠ” ìœ í˜•ìœ¼ë¡œ ë‚˜ë‰œë‹¤.
`while`ì€ í‚¤ì›Œë“œ, `count`ëŠ” ì‹ë³„ì, `<=`ëŠ” ì—°ì‚°ìë¼ëŠ” ì‹ì´ë‹¤.

##### ğŸ“„ í† í° ì˜ˆì œ
ì…ë ¥
```
while (count <= 100) {
  count++;
}
```
ì¶œë ¥
```
while
(
count
<=
100
)
{
count
++
;
}
```

#### Step 1_2. íŒŒì„œ(Parser)
ë¬¸ë²• ë¶„ì„ì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ëŠ” íŒŒì„œ ë‹¨ê³„ë‹¤. íŒŒì„œëŠ” í…ìŠ¤íŠ¸ì™€ ë¬¸ë²• ê·œì¹™ ì‚¬ì´ì˜ ì •í™•í•œ ëŒ€ì‘ ê´€ê³„ë¥¼ ê²°ì •í•˜ëŠ” ë‹¨ê³„ë‹¤.
ë¬¸ë²• ê·œì¹™ì´ ê³„ì¸µì ì´ê¸° ë•Œë¬¸ì— íŒŒì„œê°€ ìƒì„±í•˜ëŠ” ì¶œë ¥ì€ ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬(AST: Abstract Syntax Tree)ë¼ê³  ë¶ˆë¦¬ëŠ” íŠ¸ë¦¬ ê¸°ë°˜ ë°ì´í„° êµ¬ì¡°ë¡œ ê¸°ìˆ ëœë‹¤.

##### ğŸ“„ íŒŒì„œ ì˜ì‚¬ ì½”ë“œ
```js
// ast: Abstract Syntax Tree
function parser(tokens) {
  var ast = {} // logic
  return ast
}
```

##### ğŸ“„ AST ì˜ˆì œ
[í† í° ì˜ˆì œ](#-í† í°-ì˜ˆì œ)ì˜ í† í°ë“¤ì„ ASTë¡œ ë§Œë“  ì˜ˆì œë‹¤.
```
statement
â””â”€ whileStatement
   â”œâ”€ while
   â”œâ”€ (
   â”œâ”€ expression
   â”‚  â””â”€ count <= 100
   â”œâ”€ )
   â””â”€ statement
      â”œâ”€ {
      â””â”€ statementSequence
         â”œâ”€ statement
         â”‚  â””â”€ count++
         â””â”€ ;
```

> ì‚¬ë¡€: Vueì˜ íŒŒì„œ í•¨ìˆ˜ [baseParse](https://github.com/vuejs/vue-next/blob/f0d52d5428fca7c9b4b46be9c093b96f436c8b44/packages/compiler-core/src/parse.ts#L77)ì˜ ë°˜í™˜ê°’ ASTëŠ” [RootNode](https://github.com/vuejs/vue-next/blob/f0d52d5428fca7c9b4b46be9c093b96f436c8b44/packages/compiler-core/src/ast.ts#L100)ë‹¤.

### Step 2. ì½”ë“œ ìƒì„±ê¸°(Code Generator)
ì»´íŒŒì¼ëŸ¬ì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ëŠ” ì½”ë“œ ìƒì„± ë‹¨ê³„ë‹¤. ì½”ë“œ ìƒì„±ê¸°ëŠ” ASTë¥¼ í†µí•´ í”„ë¡œê·¸ë¨ì˜ ì˜ë¯¸ë¥¼ ì°¾ì•„ ì½”ë“œë¥¼ ìƒì„±í•˜ê²Œ ëœë‹¤.

##### ğŸ“„ ì½”ë“œ ìƒì„±ê¸° ì˜ì‚¬ ì½”ë“œ
```js
function codeGenerator(ast) {
  var virtualCode = virtualCodeGenerator(ast)
  var targetCode = targetCodeGenerator(virtualCode)
  return targetCode
}
```

#### Step 2_1. ê°€ìƒ ì½”ë“œ ìƒì„±ê¸°(Virtual Code Generator)
ì½”ë“œ ìƒì„±ì˜ ì²« ë‹¨ê³„ëŠ” ê°€ìƒ ì½”ë“œ ìƒì„± ë‹¨ê³„ë‹¤. ì½”ë“œ ìƒì„±ì„ í•  ë•ŒëŠ” ë°ì´í„° ë²ˆì—­ê³¼ ëª…ë ¹ ë²ˆì—­ì´ë¼ëŠ” ë‘ ë‹¨ê³„ì— ì§‘ì¤‘í•˜ëŠ” ë°, ëª…ë ¹ ë²ˆì—­ì„ ìœ„í•´ ìš°ì„ ì ìœ¼ë¡œ ê°€ìƒ ì½”ë“œë¥¼ ìƒì„±í•˜ê²Œ ëœë‹¤.

##### ğŸ“„ ê°€ìƒ ì½”ë“œ ìƒì„±ê¸° ì˜ì‚¬ ì½”ë“œ
```js
function virtualCodeGenerator(ast) {
  var virtualCode = {} // logic
  return virtualCode
}
```

##### ğŸ“„ ê°€ìƒ ì½”ë“œ ìƒì„± ì˜ˆì œ
`x + g(2, y, -z) * 5` AST
```
+
â”œâ”€ x
â””â”€ *
   â”œâ”€ g
   â”‚  â”œâ”€ 2
   â”‚  â”œâ”€ y
   â”‚  â””â”€ -
   â”‚     â””â”€ z
   â””â”€ 5
```
`x + g(2, y, -z) * 5` ê°€ìƒ ì½”ë“œ
```
push x
push 2
push y
push z
neg
call g
push 5
call multiply
add
```

#### Step 2_2. ëŒ€ìƒ ì½”ë“œ ìƒì„±ê¸°(Target Code Generator)
ì½”ë“œ ìƒì„±ì˜ ë§ˆì§€ë§‰ ë‹¨ê³„ëŠ” ëŒ€ìƒ ì½”ë“œ ìƒì„± ë‹¨ê³„ë‹¤. ëŒ€ìƒ ì½”ë“œ ìƒì„±ê¸°ëŠ” ê°€ìƒ ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ëŒ€ìƒ ì½”ë“œë¥¼ ìƒì„±í•˜ê²Œ ëœë‹¤.

##### ğŸ“„ ëŒ€ìƒ ì½”ë“œ ìƒì„±ê¸° ì˜ì‚¬ ì½”ë“œ
```js
function targetCodeGenerator(virtualCode) {
  var targetCode = '' // logic
  return targetCode
}
```

ì»´íŒŒì¼ëŸ¬ëŠ” ë§Œë“¤ê¸° ìœ„í•´ì„œëŠ” ë¬¸ë²•ì„ ìš°ì„  ì •ì˜í•´ì•¼ í•œë‹¤. í”„ë¡œê·¸ë˜ë° ë¬¸ë²•ì€ ì–´ë–»ê²Œ ì •ì˜í•˜ëŠ” ì§€ ì •ë¦¬í•´ë´¤ë‹¤.

## ë¬¸ë²• ì •ì˜
### ë¬¸ë²•ì€ ì–´ë–»ê²Œ ì •ì˜ë ê¹Œ?
ëŒ€ë¶€ë¶„ì˜ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ë“¤ì´ë‚˜ ë³µì¡í•œ íŒŒì¼ í¬ë§· ë¬¸ë²•ì„ ì •ì˜í•˜ëŠ” í˜•ì‹ ì–¸ì–´ë“¤ì€ ë¬¸ë§¥ ììœ  ë¬¸ë²•(context-free grammar)ì´ë¼ëŠ” ê·œì¹™ë“¤ë¡œ ê¸°ìˆ ëœë‹¤. ë¬¸ë§¥ ììœ  ë¬¸ë²•ì€ ì–¸ì–´ì˜ ë¬¸ë²• ìš”ì†Œë“¤ì„ ë‹¨ìˆœí•œ ìš”ì†Œë“¤ì„ ì´ìš©í•´ êµ¬ì„±í•˜ëŠ” ê·œì¹™ì´ë‹¤. ê²°êµ­ í”„ë¡œê·¸ë¨ì„ ì´í•´(ë˜ëŠ” ë¶„ì„) í•œë‹¤ëŠ” ê²ƒì€ í”„ë¡œê·¸ë¨ì˜ í…ìŠ¤íŠ¸ì™€ ë¬¸ë²• ê·œì¹™ ì‚¬ì´ì— ì •í™•í•œ ëŒ€ì‘ ê´€ê³„ë¥¼ ê²°ì •í•œë‹¤ëŠ” ëœ»ì´ ëœë‹¤.

### ë¬¸ë²• ëª…ì„¸ ì‘ì„±
ë¬¸ë²• ìš”ì†Œë“¤ì„ ì •ì˜í•  ë•Œ ì‚¬ìš©í•˜ëŠ” ë¬¸ë²• ëª…ì„¸ ì‘ì„± ë°©ë²•ì´ë‹¤. [ì°¸ê³  ë„ì„œ](#ì°¸ê³ -ë„ì„œ)ì— ì†Œê°œëœ ì‘ì„± ë°©ë²•ì„ ë°œì·Œí–ˆë‹¤.

- 'xxx': í™‘ë”°ì˜´í‘œ ë³¼ë“œì²´ëŠ” ê¸€ì ê·¸ëŒ€ë¡œ í† í°ì— ì‚¬ìš©ëœë‹¤.(ë‹¨ë§)
- xxx: ì¼ë°˜ ê¸€ê¼´ì€ ì–¸ì–´ êµ¬ì¡° ì´ë¦„ì— ì‚¬ìš©ëœë‹¤.(ë¹„ë‹¨ë§)
- (): ê´„í˜¸ëŠ” ì–¸ì–´ êµ¬ì¡°ë“¤ì„ í•˜ë‚˜ë¡œ ë¬¶ëŠ” ë° ì‚¬ìš©ëœë‹¤.
- x | y: xë˜ëŠ” yê°€ ë‚˜ì˜¬ ìˆ˜ ìˆìŒì„ ê°€ë¦¬í‚¨ë‹¤.
- x?: xê°€ 0ë²ˆ ë˜ëŠ” 1ë²ˆ ë‚˜íƒ€ë‚´ëŠ” ê²½ìš°ë¥¼ ê°€ë¦¬í‚¨ë‹¤.
- x*: xê°€ 0ë²ˆ ì´ìƒ ë‚˜íƒ€ë‚´ëŠ” ê²½ìš°ë¥¼ ê°€ë¦¬í‚¨ë‹¤.

ì—¬ê¸°ì„œ ë¬¸ë²•ì€ ë‘ ê°€ì§€ ê´€ì ìœ¼ë¡œ ë³¼ ìˆ˜ ìˆë‹¤.
- ì„ ì–¸ì  ê´€ì ì—ì„œ ë¬¸ë²•: í† í°ë“¤ì„ ë” ë†’ì€ ìˆ˜ì¤€ì˜ ë¬¸ë²• ìš”ì†Œë“¤ë¡œ ê²°í•©í•˜ëŠ” ë°©ë²•ë“¤ì„ ì •ì˜í•œ ê²ƒì´ë‹¤.
- ë¶„ì„ì  ê´€ì ì—ì„œ ë¬¸ë²•: ì£¼ì–´ì§„ í† í°ë“¤ì„ ë°›ì•„ ë¹„ë‹¨ë§, ë” ë‚®ì€ ìˆ˜ì¤€ì˜ ë¹„ë‹¨ë§, ê·¸ë¦¬ê³  ìµœì¢…ì ìœ¼ë¡œ ë” ì´ìƒ ë¶„í•´ë˜ì§€ ì•ŠëŠ” ë‹¨ë§ê¹Œì§€ë¡œ ë¶„í•´í•˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ê·œì¹™ì´ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

ì•„ë˜ ì­ ì–¸ì–´ ë¬¸ë²•ì€ [ì°¸ê³  ë„ì„œ](#ì°¸ê³ -ë„ì„œ)ì— ì†Œê°œëœ ê°€ìƒì˜ ì–¸ì–´ì— ëŒ€í•œ ë¬¸ë²•ì´ë‹¤.

#### ì­ ì–¸ì–´ ë¬¸ë²•
##### ğŸ“„ ì–´íœ˜ ìš”ì†Œ
ì­ ì–¸ì–´ì—ëŠ” ë‹¤ì„¯ ê°€ì§€ ì¢…ë¥˜ì˜ ë‹¨ë§ ìš”ì†Œ(í† í°)ê°€ ìˆë‹¤.
```
keyword:         'class' | 'constructor' | 'function' |
                 'method' | 'field' | 'static' | 'var'
symbol:          '{' | '}' | '(' | ')' | '[' | ']'
integerConstant: 0..32767ì˜ 10ì§„ìˆ˜ ìˆ«ì
stringConstant:  '"' ë”°ì˜´í‘œì™€ ì¤„ë°”ê¿ˆ ë¬¸ìë¥¼ ì œì™¸í•œ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ '"'
identifier:      ìˆ«ìë¡œ ì‹œì‘í•˜ì§€ ì•ŠëŠ”, ì˜ë¬¸ì, ìˆ«ì, ë°‘ì¤„('_')ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´
```

##### ğŸ“„ í”„ë¡œê·¸ë¨ êµ¬ì¡°
ì­ í”„ë¡œê·¸ë¨ì€ í´ë˜ìŠ¤ë¡œ ì´ë£¨ì–´ì ¸ ìˆìœ¼ë©°, í´ë˜ìŠ¤ë“¤ì€ ê°ê° ë‹¤ë¥¸ íŒŒì¼ì— ìˆë‹¤. ì»´íŒŒì¼ ë‹¨ìœ„ëŠ” í´ë˜ìŠ¤ í•˜ë‚˜ë‹¤. í´ë˜ìŠ¤ëŠ” ë‹¤ìŒ ë¬¸ë§¥ ììœ  êµ¬ë¬¸ì„ ë”°ë¼ êµ¬ì¡°í™”ëœ, í† í°ì˜ ì—°ì†ì—´ì´ ëœë‹¤.
```
class:          'class' className '{' classVarDec* subroutineDec* '}'
classVarDec:    ('static' | 'field') type varName (',' varName)* ';'
type:           'int' | 'char' | 'boolean' | className
subroutineDec:  ('constructor' | 'function' | 'method')
                ('void' | type) subroutineName '(' parameterList ')'
                subroutineBody
parameterList:  ((type varName) (',' type varName)*)?
subroutineBody: '{' varDec* statements '}'
varDec:         'var' type varName (',' varName)* ';'
className:      identifier
subroutineName: identifier
varName:        identifier
```

##### ğŸ“„ ëª…ë ¹ë¬¸
```
statements:      statement*
statement:       letStatement | ifStatement | whileStatement
                 doStatement | returnStatement
letStatement:    'let' varName ('[' expression ']')? '=' expression ';'
ifStatement:     'if' '(' expression ')' '{' statement '}'
                 ('else' '{' statements '}')?
whileStatement:  'while' '(' expression ')' '{' statements '}'
doStatement:     'do' subroutineCall ';'
returnStatement: 'return' expression? ';'
```

##### ğŸ“„ í‘œí˜„ì‹
```
expression:      term (op term)*
term:            integerConstant | stringConstant | keywordConstant |
                 varName | varName '[' expression ']' | subroutineCall |
                 '(' expression ')' | unaryOp term
subroutineCall:  subroutineName '(' expressionList ')' | (className |
                 varName) '.' subroutineName '(' expressionList ')'
expressionList:  (expression (',' expression)* )?
op:              '+' | '-' | '*' | '/' | '&' | '|' | '<' | '>' | '='
unaryOp:         '-' | '~'
keywordConstant: 'true' | 'false' | 'null' | 'this'
```

### ë¬¸ë²• ë¶„ì„í•˜ëŠ” ë°©ë²•
í† í°í™”ëœ í† í°ë“¤ì˜ ë¬¸ë²•ì„ ë¶„ì„í•´ íŒŒì‹±í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜í–¥ì‹(top-down) ì ‘ê·¼ë²•ìœ¼ë¡œ ì¬ê·€ì  í•˜ì–‘ íŒŒì„œ(recursive descent parsing)ê°€ ìˆë‹¤. ì´ ë°©ë²•ì€ ë¬¸ë²•ì— ì •ì˜ëœ ì¤‘ì²© êµ¬ì¡°ë¥¼ ì´ìš©í•´ í† í° ìŠ¤íŠ¸ë¦¼ì„ ì¬ê·€ì ìœ¼ë¡œ ë¶„ì„í•˜ëŠ” ë°©ë²•ì´ë‹¤.

ë¹„ë‹¨ë§ ë¬¸ë²•ì˜ ëª¨ë“  ê·œì¹™ë§ˆë‹¤ ê·¸ ê·œì¹™ì„ ë¶„ì„í•˜ê¸° ìœ„í•œ ì¬ê·€ì  ë£¨í‹´ë“¤ì„ í•˜ë‚˜ì”© ë§Œë“¤ ìˆ˜ ìˆë‹¤.
ë¬¸ë²•ì„ ë”°ë¥´ëŠ” ì¬ê·€ì  í•˜í–¥ íŒŒì„œë¥¼ ë§Œë“ ë‹¤ê³  ê°€ì •í•˜ë©´, ë¬¸ë²•ì—ì„œ ìœ ë„ë˜ëŠ” ê·œì¹™ì— ë§ê²Œ ìˆ˜ì •í•  ìˆ˜ ìˆë‹¤.

- statement: `parseStatement()`
- whileStatement: `parseWhileStatement()`
- expression: `parseExpression()`

#### ë¬¸ë²• ë¶„ì„ ì˜ˆì‹œ
í¸ì˜ìƒ í† í°í™” ê³¼ì •ì€ ìƒëµí•˜ê³ , ì´ ë¬¸ë²•ìœ¼ë¡œ
```
symbol: '{' | '}' | '(' | ')' | '[' | ']
integerConstant: 0..32767ì˜ 10ì§„ìˆ˜ ìˆ«ì
stringConstant: '"' ë”°ì˜´í‘œì™€ ì¤„ë°”ê¿ˆ ë¬¸ìë¥¼ ì œì™¸í•œ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ '"'
identifier: ìˆ«ìë¡œ ì‹œì‘í•˜ì§€ ì•ŠëŠ”, ì˜ë¬¸ì, ìˆ«ì, ë°‘ì¤„('_')ë¡œ ì´ë£¨ì–´ì§„ ë¬¸ìì—´

statement: whileStatement | assignStatement
whileStatement: 'while' '(' expression ')' '{' statement '}'
assignStatement: varName '=' expression

expression: term (op term)*
term: integerConstant | stringConstant | varName
op: '+'| '<=' | '='
```

ì´ ì½”ë“œë¥¼ ë¶„ì„í•œë‹¤ê³  ê°€ì •í•˜ê² ë‹¤.
```
while (count <= 100) {
  count = count + 1
}
```

íŒŒì‹±ì„ ì‹œì‘í•  ë•ŒëŠ” ì…ë ¥ì˜ ì²« ë²ˆì§¸ í† í°ì´ ë¬´ì—‡ì¸ì§€ ê²°ì •ë¶€í„°í•œë‹¤. ì²«ë²ˆì§¸ í† í° `while` ì‹ë³„í•˜ê³ , ë¬¸ë²•ì— ë§ê²Œ íŒŒì‹± í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œë‹¤.

ì½”ë“œë¥¼ ë¶„ì„í•˜ë©´ ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.

1. `while` ì‹ë³„
2. `parseWhileStatement()` í•¨ìˆ˜ ì‹¤í–‰
3. `(` ì‹ë³„
4. `parseExpression()` í•¨ìˆ˜ ì‹¤í–‰
5. `count`, `<=`, `100` ì‹ë³„
6. `)`
7. `parseAssignStatement()` í•¨ìˆ˜ ì‹¤í–‰
8. `{`, `count`, `=` ì‹ë³„
9. `parseExpression()` í•¨ìˆ˜ ì‹¤í–‰
10. `count`, `+`, `1` ì‹ë³„
11. `}` ì‹ë³„
12. ì¢…ë£Œ

ê²°ë¡ ì ìœ¼ë¡œ ì´ëŸ° í˜•íƒœì˜ íŠ¸ë¦¬ê°€ ë§Œë“¤ì–´ì§„ë‹¤.

```
statement
â””â”€ whileStatement
   â”œâ”€ while
   â”œâ”€ (
   â”œâ”€ expression
   â”‚  â””â”€ count <= 100
   â”œâ”€ )
   â””â”€ statement
      â””â”€ assignStatement
         â”œâ”€ {
         â”œâ”€ varName
         â”‚  â””â”€ count
         â”œâ”€ '='
         â”œâ”€ expression
         â”‚  â””â”€ count + 1
         â””â”€ }
```

## ì°¸ê³  ë„ì„œ
- ë…¸ì•” ë‹ˆì‚°, ì‹œëª¬ ì‡¼ì¼„. ã€ë°‘ë°”ë‹¥ë¶€í„° ë§Œë“œëŠ” ì»´í“¨íŒ… ì‹œìŠ¤í…œã€. ê¹€ì§„í™(ì—­). ì¸ì‚¬ì´íŠ¸, 2019.
