(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{328:function(t,e,r){"use strict";r.r(e);var a=r(28),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"글의-목적"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#글의-목적"}},[t._v("#")]),t._v(" 글의 목적")]),t._v(" "),r("blockquote",[r("p",[t._v("정보 전달 목적보다는 자료 정리 목적으로 작성된 포스트라 정돈이 안되있다.")])]),t._v(" "),r("p",[t._v("AngularJs를 사용한 프로젝트에서 성능 이슈로 밤낮세며 개선 방안을 찾은 기억이 있다. 그 경험 때문에 라이브러리들의 옵져버 매커니즘은 어떻게 구현되는 지 가끔 살펴본다. 개인적으로는 그 중에 VueJs의 옵져버 매커니즘은 가장 이상적이라고 생각한다. 각 라이브러리 별로 구현된 옵져버 매커니즘을 정리해본 자료이다.")]),t._v(" "),r("h3",{attrs:{id:"목차"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#목차"}},[t._v("#")]),t._v(" 목차")]),t._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"#AngularJs"}},[t._v("AngularJs")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#Angular"}},[t._v("Angular")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#VueJs"}},[t._v("VueJs")])]),t._v(" "),r("li",[r("a",{attrs:{href:"#React"}},[t._v("React")])])]),t._v(" "),r("h3",{attrs:{id:"라이브러리별-옵져버-매커니즘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#라이브러리별-옵져버-매커니즘"}},[t._v("#")]),t._v(" 라이브러리별 옵져버 매커니즘")]),t._v(" "),r("h4",{attrs:{id:"angularjs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#angularjs"}},[t._v("#")]),t._v(" AngularJs")]),t._v(" "),r("p",[t._v("먼저 왜 AngularJs에서 성능 이슈를 발생했는 지 정리했다.")]),t._v(" "),r("p",[t._v("AngularJs는 "),r("strong",[t._v("$digest loop")]),t._v("를 통해서 변경 감지를 하는 데, "),r("strong",[t._v("$digest loop")]),t._v("는 "),r("strong",[t._v("$watcher")]),t._v("에 등록된 모델의 변경 체크하고 변경 시 "),r("strong",[t._v("$watcher")]),t._v("에 등록된 이벤트 핸들러를 실행한다.")]),t._v(" "),r("p",[t._v("만약에 모델의 변경이 됬다면 "),r("strong",[t._v("$digest loop")]),t._v("를 다시 실행하게 되고 이것을 "),r("strong",[t._v("Dirty Checking")]),t._v("이라고 불린다. 이 과정에서 성능이슈가 발생하게 되고 모델과 디렉티브를 많이 사용하게 되면 성능이 급격히 감소한다.")]),t._v(" "),r("h4",{attrs:{id:"vuejs"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vuejs"}},[t._v("#")]),t._v(" VueJs")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://kr.vuejs.org/v2/guide/reactivity.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 2.0 반응형에 대해 깊이 알아보기"),r("OutboundLink")],1)])]),t._v(" "),r("p",[r("strong",[t._v("Vue 2.0")]),t._v("에서는 "),r("strong",[t._v("Object.defineProperty")]),t._v("를 통해서 구현되있다.\n"),r("strong",[t._v("data")]),t._v(" 옵션으로 전달되는 모든 속성을 "),r("strong",[t._v("Object.defineProperty")]),t._v("를 통해 변경 감지를 한다. 하지만 "),r("strong",[t._v("Object.defineProperty")]),t._v("의 한계는 존재한다.")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("- ES5 지원 브라우저만 동작\n- 속성 추가 감지할 수 없음\n- data는 배열로 선언할 수 없음\n")])])]),r("p",[t._v("이러한 단점이 있지만 모든 반응 속성을 미리 선언하여 컴포넌트 상태 스키마로 사용 되기 때문에 코드 유지 관리 측면에서 장점이 있다.\n자세한 구현내용은 "),r("a",{attrs:{href:"https://www.vuemastery.com/courses/advanced-components/build-a-reactivity-system",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue Mastery - Build a Reactivity System"),r("OutboundLink")],1),t._v(" 에서 확인할 수 있다.")]),t._v(" "),r("p",[r("strong",[t._v("Vue 3.0")]),t._v("에서는 "),r("strong",[t._v("Proxy")]),t._v("를 통해서 구현되있다.")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("- Property addition / deletion\n- Array index / length mutation\n- Map, Set, WeakMap, WeakSet\n- Classes\n")])])]),r("p",[r("a",{attrs:{href:"https://www.youtube.com/watch?v=8Hgt9HYaCDA",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 3.0을 소개하는 영상"),r("OutboundLink")],1),t._v("에서 Evan You는 Proxy-based의 장점을 설명했다.\n"),r("strong",[t._v("Object.defineProperty")]),t._v("의 단점을 보완이 가능해졌고, 성능도 향상되었다. "),r("a",{attrs:{href:"https://www.vuemastery.com/courses/advanced-components/evan-you-on-proxies",target:"_blank",rel:"noopener noreferrer"}},[t._v("Evan You on Proxies"),r("OutboundLink")],1),t._v("에서 변경하려는 의지를 보였던 거 같다.")]),t._v(" "),r("h4",{attrs:{id:"angular"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#angular"}},[t._v("#")]),t._v(" Angular")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/angular/angular/search?l=TypeScript&q=defineProperty&type=",target:"_blank",rel:"noopener noreferrer"}},[t._v("Angular defineProperty"),r("OutboundLink")],1),t._v(" 검색")])]),t._v(" "),r("p",[t._v("Angular부터는 변경 감지를 "),r("strong",[t._v("Object.defineProperty")]),t._v("를 통해 구현했다. 그리고 RxJs의 Observable는 Vanilla Js로 "),r("strong",[t._v("Subject와 Observable 패턴")]),t._v("이 구현되있다.")]),t._v(" "),r("h4",{attrs:{id:"react"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react"}},[t._v("#")]),t._v(" React")]),t._v(" "),r("blockquote",[r("p",[r("a",{attrs:{href:"https://github.com/facebook/react/search?utf8=%E2%9C%93&q=defineProperty&type=",target:"_blank",rel:"noopener noreferrer"}},[t._v("React defineProperty"),r("OutboundLink")],1),t._v(" 검색")])]),t._v(" "),r("p",[t._v("React도 변경감지를 "),r("strong",[t._v("Object.defineProperty")]),t._v("를 통해 구현했다. 적용 범위는 이벤트, 입력폼, Props 등에 사용되었다.")]),t._v(" "),r("h3",{attrs:{id:"끝"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#끝"}},[t._v("#")]),t._v(" 끝")]),t._v(" "),r("p",[t._v("Angular와 React는 공식적으로 어떻게 구현되었는 지 자료가 없다.\n그래서 Github 코드를 통해서 확인하는 과정으로 작성했다.")])])}),[],!1,null,null,null);e.default=s.exports}}]);