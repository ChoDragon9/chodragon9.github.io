(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{210:function(e,t,l){e.exports=l.p+"assets/img/mvvm.065dc3df.svg"},306:function(e,t,l){"use strict";l.r(t);var s=l(28),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h2",{attrs:{id:"mvvm"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[e._v("#")]),e._v(" MVVM")]),e._v(" "),s("p",[e._v("MVC에서 파생되는 패턴들은 모델과 뷰 사이에 무언가를 넣는 것이다. 뷰를 가상화하는 프록시를 가짐으로서 뷰와 모델간의 관계를 끊는 다. 모델의 데이터 형태가 뷰에게 의존이 생기기 때문에 모델의 변경이 필요할 때는 뷰까지 변경이 이뤄짐으로 변경을 할 때 비용이 많이 든다. 그래서 모델의 데이터 형태와 뷰 렌더링을 위한 데이터 형태를 분리하기 위해 객체를 만들어서 의존성을 해결한다. 뷰를 위한 데이터이기 때문에 뷰모델이라고 부른다. 뷰와 뷰모델은 양방향 바인디잉 이뤄진다. 뷰와 뷰모델은 변경이 되었을 때 서로 변경이 됬음을 알려준다.")]),e._v(" "),s("p",[e._v("Model과 View는 MVC에서 정의된 역할과 동일합니다. Model은 상태저장, 비즈니스 로직, 순수한 데이터입니다. View는 시각적인 요소를 담당합니다.")]),e._v(" "),s("p",[e._v("ViewModel는 View가 데이터 바인딩에 사용할 수 있는 Model을 전문화합니다.")]),e._v(" "),s("ul",[s("li",[e._v("Model Type을 View Type으로 변환하는 데이터 변환기 역할")]),e._v(" "),s("li",[e._v("View가 Model과 상호작용 할 수 있게 하는 역할")]),e._v(" "),s("li",[e._v("UI의 재사용 가능한 부분에 대한 추상적 표현")]),e._v(" "),s("li",[e._v("Selection과 Commands를 포함")])]),e._v(" "),s("p",[s("img",{attrs:{src:l(210),alt:""}})])])}),[],!1,null,null,null);t.default=v.exports}}]);