(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{314:function(v,_,t){"use strict";t.r(_);var s=t(28),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h4",{attrs:{id:"생성패턴"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#생성패턴"}},[v._v("#")]),v._v(" 생성패턴")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("싱글턴")]),v._v(" : 오직 한 개의 인스턴스 보장, 전역적인 접근 제공")]),v._v(" "),t("li",[t("strong",[v._v("팩토리 메서드")]),v._v(" : 객체 생성 인터페이스 정의, 서브클래스에서 클래스 생성 결정")]),v._v(" "),t("li",[t("strong",[v._v("추상 팩토리")]),v._v(" : 객체 생성과 표현을 분리")]),v._v(" "),t("li",[t("strong",[v._v("프로토타입")]),v._v(" : 원형 복사해서 새로운 객체 생성")]),v._v(" "),t("li",[t("strong",[v._v("빌더")]),v._v(" : 복잡한 객체 생성의 동일한 절차 제공")])]),v._v(" "),t("h4",{attrs:{id:"구조패턴"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#구조패턴"}},[v._v("#")]),v._v(" 구조패턴")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("프록시")]),v._v(" : 다른 객체에 대한 접근 제어")]),v._v(" "),t("li",[t("strong",[v._v("퍼사드")]),v._v(" : 인터페이스를 집합에 대한 획일화된 하나의 인터페이스 제공")]),v._v(" "),t("li",[t("strong",[v._v("데코레이터")]),v._v(" : 객체 동적 새로운 책임 추가")]),v._v(" "),t("li",[t("strong",[v._v("컴포지트")]),v._v(" : 하나의 추상 클래스로 부분과 전체의 계층을 표현")]),v._v(" "),t("li",[t("strong",[v._v("브릿지")]),v._v(" : 구현에서 추상을 분리하여, 이들이 독립적으로 다양성을 가질 수 있도록 함")]),v._v(" "),t("li",[t("strong",[v._v("어뎁터")]),v._v(" : 서로 일치하지 않는 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응")]),v._v(" "),t("li",[t("strong",[v._v("플라이웨이트")]),v._v(" : 많은 수의 객체를 효율적으로 제공하기 위해 공유개념을 이용")])]),v._v(" "),t("h4",{attrs:{id:"행동패턴"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#행동패턴"}},[v._v("#")]),v._v(" 행동패턴")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("이터레이터")]),v._v(" : 내부 표현부를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("옵져버")]),v._v(" : 객체 사이에 일 대 다의 의존 관계를 정의해 두어, 어떤 객체의 상태가 변할 때 그 객체의 의존성을 가진 다른 객체들이 그 변화를 통지받고 자동으로 갱신될 수 있게 만드는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("상태")]),v._v(" : 객체의 내부 상태에 따라 스스로 행동을 변경할 수 있게 끔 허가하는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("전략")]),v._v(" : 동일 계열의 알고리즘군을 정의하고, 각각의 알고리즘을 캡슐화하여, 이 들을 상호교환이 가능하도록 만드는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("책임연쇄")]),v._v(" : 하나의 요청에 대한 처리가 반드시 한 객체에거만 되지 않고, 여러 객체에서 그 처리 기회줌")]),v._v(" "),t("li",[t("strong",[v._v("커멘드")]),v._v(" : 요청 자체 캡슐화, 요청 대기/로깅하여, 되돌릴 수 있는 연산을 지원")]),v._v(" "),t("li",[t("strong",[v._v("탬플릿 메소드")]),v._v(" : 알고리즘의 뼈대만을 정의하고 각 단계에서 수행할 구체적 처리는 서브클래스쪽으로 미루는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("방문자")]),v._v(" : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.")]),v._v(" "),t("li",[t("strong",[v._v("중재자(미디에이터)")]),v._v(" : 한 집합에 속해있는 객체들의 상호작용을 캡슐화하는 중앙객체를 정의하는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("메멘토")]),v._v(" : 캡슐화를 위배하지 않는 채 어떤 객체의 내부상태를 잡아내고 신체화시켜, 이후에 해당 객체가 그 상태로 다시 되돌아올 수 있도록 하는 패턴")]),v._v(" "),t("li",[t("strong",[v._v("인터프리터")]),v._v(" : 주어진 언어에 대해, 그 언어의 문법을 위한 표현 수단을 정의하고, 이와 어울러 그 표현수단을 사용하여 해당 언어로 작성된 문장을 해석하는 해석기를 정의하는 패턴이다.")])])])}),[],!1,null,null,null);_.default=r.exports}}]);